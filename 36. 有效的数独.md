# [36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

判断一个 9x9 的数独是否有效。只需要**根据以下规则**，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

**示例 1:**

```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```

**示例 2:**

```
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

**说明:**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 给定数独序列只包含数字 `1-9` 和字符 `'.'` 。
- 给定数独永远是 `9x9` 形式的。

```c
// 使用数组模拟hash表，分别进行每一行、每一列和各个矩阵的数独判断
// 对于行列来讲，较为简单，将控制元素的i、j变量互换即可
// 对于3 * 3的元素矩阵，使用公式 [i + k / 3 * 3][j + k % 3 * 3] 
// 得到元素，为本题的一个小技巧
bool isValidSudoku(char** board, int boardRowSize, int boardColSize) {
    int hashMap[256] = {0};
    
    // 判断每一行
    for(int i = 0 ; i < boardRowSize; i++)
    {
        memset(hashMap,0,sizeof(int) * 256);
        for(int j = 0; j < boardColSize;j++)
        {
            hashMap[board[i][j]]++;
            if(board[i][j] != '.' && hashMap[board[i][j]] > 1)
                return false;
        }
    }
    
    // 判断每一列
    for(int i = 0 ; i < boardColSize; i++)
    {
        memset(hashMap,0,sizeof(int) * 256);
        for(int j = 0; j < boardRowSize;j++)
        {
            hashMap[board[j][i]]++;
            if(board[j][i] != '.' && hashMap[board[j][i]] > 1)
                return false;
        }
    }   
    
    // 判断3 * 3 矩阵
    for(int k = 0; k < 9; k++)
    {
        memset(hashMap,0,sizeof(int) * 256);
        for(int i = 0; i < 3; i++)
        {
            for(int j = 0; j < 3; j++)
            {
                hashMap[board[i + k / 3 * 3][j + k % 3 * 3]]++;
            if(board[i + k / 3 * 3][j + k % 3 * 3] != '.' && hashMap[board[i + k / 3 * 3][j + k % 3 * 3]] > 1)
                return false;
            }
        }
    }
    
    return true;   
}
```